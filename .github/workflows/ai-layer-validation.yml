name: AI-Powered Infrastructure Validation

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - 'apps-devstg/us-east-1/secrets-manager/**/*.tf'
      - 'apps-devstg/us-east-1/secrets-manager/**/*.tfvars'
      - 'apps-devstg/us-east-1/secrets-manager/**/*.hcl'
  issue_comment:
    types: [created]

permissions:
  contents: read       # Required to read repository contents
  pull-requests: write # Required to post PR comments
  issues: write        # Required for @aibot interactions
  models: read         # Required for GitHub Models API

env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  AWS_REGION: us-east-1

jobs:
  # Job 1: Detect affected layers from changed files
  detect-layers:
    name: Detect Modified Layers
    runs-on: ubuntu-latest
    outputs:
      layers: ${{ steps.parse-layers.outputs.layers }}
      has-changes: ${{ steps.parse-layers.outputs.has-changes }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Parse modified layers
        id: parse-layers
        run: |
          # Get changed files
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            CHANGED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }}..${{ github.event.pull_request.head.sha }})
          else
            CHANGED_FILES=$(git diff --name-only HEAD~1)
          fi

          echo "Changed files:"
          echo "$CHANGED_FILES"

          # Extract unique layer paths
          LAYERS=$(echo "$CHANGED_FILES" | grep -E '\.(tf|tfvars|hcl)$' | grep -E '^apps-devstg/us-east-1/secrets-manager/' | head -1 | xargs dirname | sort | uniq | jq -R -s -c 'split("\n")[:-1]')

          if [[ "$LAYERS" == "[]" || "$LAYERS" == "" ]]; then
            echo "has-changes=false" >> $GITHUB_OUTPUT
            echo "layers=[]" >> $GITHUB_OUTPUT
          else
            echo "has-changes=true" >> $GITHUB_OUTPUT
            echo "layers=$LAYERS" >> $GITHUB_OUTPUT
          fi

          echo "Detected layers: $LAYERS"


  # Job 2: Validate each affected layer
  validate-layer:
    name: Validate Layer (${{ matrix.layer }})
    runs-on: ubuntu-latest
    needs: detect-layers
    if: needs.detect-layers.outputs.has-changes == 'true'
    strategy:
      matrix:
        layer: ${{ fromJson(needs.detect-layers.outputs.layers) }}
      fail-fast: false

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.13'
          cache: 'pip'

      - name: Setup Python virtual environment and Install Leverage CLI
        run: |
          echo "🐍 Creating Python virtual environment (mirroring local setup)"
          python3 -m venv ~/.leverage-venv
          source ~/.leverage-venv/bin/activate

          echo "📦 Installing latest Leverage CLI in virtual environment"
          pip install --upgrade pip
          pip install leverage

          echo "🔧 Configuring environment for subsequent steps"
          echo "VIRTUAL_ENV=$HOME/.leverage-venv" >> $GITHUB_ENV
          echo "$HOME/.leverage-venv/bin" >> $GITHUB_PATH

          echo "✅ Leverage CLI installed in virtual environment"
          leverage --version

      - name: Configure AWS credentials for Leverage CLI containers
        run: |
          # Parse layer information to determine AWS account
          LAYER_PATH="${{ matrix.layer }}"
          ACCOUNT=$(echo "$LAYER_PATH" | cut -d'/' -f1)

          echo "🔑 Configuring AWS credentials for Leverage CLI containers - Account: $ACCOUNT"

          # Simple environment variable setup for Leverage CLI containers
          echo "AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}" >> $GITHUB_ENV
          echo "AWS_DEFAULT_REGION=${{ env.AWS_REGION }}" >> $GITHUB_ENV
          echo "AWS_REGION=${{ env.AWS_REGION }}" >> $GITHUB_ENV

          echo "✅ AWS credentials configured for Leverage CLI containers"

      - name: Determine Terraform binary
        working-directory: ${{ matrix.layer }}
        run: |
          # Default to OpenTofu
          TF_COMMAND="tf"
          TF_BINARY="OpenTofu (default)"

          echo "✅ Selected binary: $TF_BINARY (command: leverage $TF_COMMAND)"
          echo "TF_COMMAND=$TF_COMMAND" >> $GITHUB_ENV

      - name: Setup Leverage environment
        working-directory: ${{ matrix.layer }}
        run: |
          # Navigate to repository root and create minimal build.env
          REPO_ROOT=$(git rev-parse --show-toplevel)
          cd "$REPO_ROOT"

          # Create minimal build.env configuration
          cat > build.env << EOF
          PROJECT=bb
          MFA_ENABLED=false
          TERRAFORM_IMAGE_TAG=1.9.1-tofu-0.3.0
          EOF

          # Source environment for subsequent steps
          source build.env
          echo "PROJECT=$PROJECT" >> $GITHUB_ENV
          echo "MFA_ENABLED=$MFA_ENABLED" >> $GITHUB_ENV
          echo "TERRAFORM_IMAGE_TAG=$TERRAFORM_IMAGE_TAG" >> $GITHUB_ENV

          echo "✅ Leverage environment configured with image: $TERRAFORM_IMAGE_TAG"

      - name: Setup Leverage environment
        working-directory: ${{ matrix.layer }}
        run: |
          # Setup Leverage environment with SSH agent socket fix
          ${GITHUB_WORKSPACE}/.github/scripts/setup-leverage-environment.sh

      - name: Run Terraform validation
        working-directory: ${{ matrix.layer }}
        run: |
          echo "🚀 Starting Terraform validation for layer: ${{ matrix.layer }}"

          # Ensure virtual environment is active
          source ~/.leverage-venv/bin/activate

          # Configuration paths
          BACKEND_CONFIG="../../config/backend.tfvars"
          VALIDATION_RESULTS=""
          VALIDATION_STATUS="success"

          # Run format check
          echo "📝 Running format check..."
          if output=$(leverage tf format -check 2>&1); then
            echo "✅ Format check passed"
            VALIDATION_RESULTS="${VALIDATION_RESULTS}## Terraform Format Check\n✅ **PASSED**\n\n"
          else
            echo "⚠️ Format check failed"
            VALIDATION_RESULTS="${VALIDATION_RESULTS}## Terraform Format Check\n⚠️ **FAILED**\n\`\`\`\n${output}\n\`\`\`\n\n"
          fi

          # Initialize Terraform
          echo "⚡ Initializing Terraform..."
          if output=$(leverage tf init -no-color -backend-config=$BACKEND_CONFIG 2>&1); then
            echo "✅ Initialization successful"
            VALIDATION_RESULTS="${VALIDATION_RESULTS}## Terraform Initialization\n✅ **PASSED**\n\n"
          else
            echo "⚠️ Backend init failed, trying syntax-only validation..."
            VALIDATION_RESULTS="${VALIDATION_RESULTS}## Terraform Initialization\n⚠️ **BACKEND FAILED** - trying syntax-only\n\`\`\`\n${output}\n\`\`\`\n\n"

            if fallback_output=$(leverage tf init -no-color -backend=false 2>&1); then
              echo "✅ Syntax-only initialization successful"
              VALIDATION_RESULTS="${VALIDATION_RESULTS}## Terraform Syntax Initialization\n✅ **PASSED**\n\n"
            else
              echo "❌ Syntax-only initialization failed"
              VALIDATION_RESULTS="${VALIDATION_RESULTS}## Terraform Syntax Initialization\n❌ **FAILED**\n\`\`\`\n${fallback_output}\n\`\`\`\n\n"
              VALIDATION_STATUS="failed"
            fi
          fi

          # Run validation
          echo "🔍 Running Terraform validation..."
          if [[ "$VALIDATION_STATUS" != "failed" ]]; then
            if output=$(leverage tf validate 2>&1); then
              echo "✅ Validation successful"
              VALIDATION_RESULTS="${VALIDATION_RESULTS}## Terraform Validation\n✅ **PASSED**\n\n"
            else
              echo "❌ Validation failed"
              VALIDATION_RESULTS="${VALIDATION_RESULTS}## Terraform Validation\n❌ **FAILED**\n\`\`\`\n${output}\n\`\`\`\n\n"
              VALIDATION_STATUS="failed"
            fi
          fi

          # Create validation results
          mkdir -p /tmp/validation-results
          echo -e "$VALIDATION_RESULTS" > /tmp/validation-results/validation-summary.md
          echo "$VALIDATION_STATUS" > /tmp/validation-results/validation-status.txt

          echo "🎯 Validation completed with status: $VALIDATION_STATUS"
          if [[ "$VALIDATION_STATUS" == "failed" ]]; then
            echo "❌ Validation failed"
            exit 1
          else
            echo "✅ All validation steps passed"
          fi

      - name: Set artifact name
        run: |
          # Replace forward slashes with hyphens for artifact name
          ARTIFACT_NAME="validation-results-$(echo '${{ matrix.layer }}' | sed 's|/|-|g')"
          echo "ARTIFACT_NAME=$ARTIFACT_NAME" >> $GITHUB_ENV

      - name: Upload validation results
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.ARTIFACT_NAME }}
          path: /tmp/validation-results/
          retention-days: 1
          if-no-files-found: warn
        continue-on-error: true


  # Job 3: AI Analysis and PR Comment
  ai-analysis-and-comment:
    name: AI Analysis and PR Comment
    runs-on: ubuntu-latest
    needs: [detect-layers, validate-layer]
    if: always() && needs.detect-layers.outputs.has-changes == 'true'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download validation results
        uses: actions/download-artifact@v4
        with:
          path: validation-results

      - name: Load personas configuration
        id: load-personas
        run: |
          echo "Loading AI personas from configuration..."
          if [[ -f ".github/ai-personas.yml" ]]; then
            echo "personas-available=true" >> $GITHUB_OUTPUT
            echo "✅ Personas configuration found"
          else
            echo "personas-available=false" >> $GITHUB_OUTPUT
            echo "⚠️ No personas configuration found, using default prompts"
          fi

      - name: Select appropriate AI persona
        id: select-persona
        run: |
          # Get the first layer from the validation results for persona selection
          FIRST_LAYER=$(find validation-results -name "validation-summary.md" | head -1 | xargs dirname | xargs basename | sed 's/validation-results-//' | sed 's/-/\//g')
          echo "Analyzing layer: $FIRST_LAYER"

          # Simple persona selection based on layer patterns
          if [[ "$FIRST_LAYER" =~ (security|secrets|identities|iam) ]]; then
            PERSONA="Security Expert 🔐"
            SYSTEM_PROMPT="You are a specialized AWS Security Expert focusing on IAM, KMS encryption, secrets management, and security compliance. Analyze the following Terraform validation results and provide security-focused recommendations."
          elif [[ "$FIRST_LAYER" =~ (network|vpc|vpn) ]]; then
            PERSONA="Network Specialist 🌐"
            SYSTEM_PROMPT="You are a specialized AWS Network Expert focusing on VPC design, routing, load balancing, and network security. Analyze the following Terraform validation results and provide network-focused recommendations."
          elif [[ "$FIRST_LAYER" =~ (database|rds|aurora|dynamodb) ]]; then
            PERSONA="Database Administrator 🗄️"
            SYSTEM_PROMPT="You are a specialized AWS Database Expert focusing on RDS, Aurora, DynamoDB, and database security. Analyze the following Terraform validation results and provide database-focused recommendations."
          elif [[ "$FIRST_LAYER" =~ (k8s|eks|ecs|container) ]]; then
            PERSONA="Container Expert 🐳"
            SYSTEM_PROMPT="You are a specialized AWS Container Expert focusing on EKS, ECS, container security, and orchestration. Analyze the following Terraform validation results and provide container-focused recommendations."
          elif [[ "$FIRST_LAYER" =~ (tools|monitoring|observability) ]]; then
            PERSONA="DevOps Specialist ⚙️"
            SYSTEM_PROMPT="You are a specialized DevOps Expert focusing on monitoring, observability, CI/CD, and operational tools. Analyze the following Terraform validation results and provide DevOps-focused recommendations."
          elif [[ "$FIRST_LAYER" =~ (s3|backup|storage) ]]; then
            PERSONA="Storage Expert 💾"
            SYSTEM_PROMPT="You are a specialized AWS Storage Expert focusing on S3, backup strategies, and data lifecycle management. Analyze the following Terraform validation results and provide storage-focused recommendations."
          elif [[ "$FIRST_LAYER" =~ (ec2|lambda|compute) ]]; then
            PERSONA="Compute Expert ⚡"
            SYSTEM_PROMPT="You are a specialized AWS Compute Expert focusing on EC2, Lambda, auto-scaling, and compute optimization. Analyze the following Terraform validation results and provide compute-focused recommendations."
          elif [[ "$FIRST_LAYER" =~ (data|analytics|bedrock|ml) ]]; then
            PERSONA="Data Analytics Expert 📊"
            SYSTEM_PROMPT="You are a specialized AWS Data & Analytics Expert focusing on data lakes, ML/AI services, and Bedrock integration. Analyze the following Terraform validation results and provide data-focused recommendations."
          else
            PERSONA="Infrastructure Generalist 🏗️"
            SYSTEM_PROMPT="You are an AWS Infrastructure Expert with broad knowledge across all AWS services. Analyze the following Terraform validation results and provide comprehensive infrastructure recommendations."
          fi

          echo "Selected persona: $PERSONA"
          echo "persona=$PERSONA" >> $GITHUB_OUTPUT
          echo "system_prompt=$SYSTEM_PROMPT" >> $GITHUB_OUTPUT

      - name: Prepare validation summary
        id: prepare-summary
        run: |
          echo "📋 Preparing validation summary for AI analysis..."

          # Combine all validation results
          SUMMARY=""
          for file in $(find validation-results -name "validation-summary.md"); do
            LAYER_NAME=$(echo "$file" | xargs dirname | xargs basename | sed 's/validation-results-//' | sed 's/-/\//g')
            echo "## Layer: $LAYER_NAME" >> combined-summary.md
            cat "$file" >> combined-summary.md
            echo "" >> combined-summary.md
          done

          # Read the combined summary
          if [[ -f "combined-summary.md" ]]; then
            SUMMARY=$(cat combined-summary.md)
            echo "✅ Validation summary prepared"
          else
            SUMMARY="No validation results found"
            echo "⚠️ No validation results available"
          fi

          # Save to output (truncate if too long for GitHub)
          echo "validation_summary<<EOF" >> $GITHUB_OUTPUT
          echo "$SUMMARY" | head -c 8000 >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Run AI analysis
        id: ai-analysis
        uses: actions/ai-inference@v1
        with:
          model: 'gpt-4o'
          system-prompt: ${{ steps.select-persona.outputs.system_prompt }}
          prompt: |
            Analyze the following Terraform validation results for infrastructure layer(s):

            ${{ steps.prepare-summary.outputs.validation_summary }}

            Please provide:
            1. **Overall Assessment**: Summary of validation status
            2. **Key Findings**: Important issues or successes identified
            3. **Recommendations**: Specific actions to improve the infrastructure
            4. **Security Considerations**: Any security implications (if applicable)
            5. **Best Practices**: Suggestions for following AWS/Terraform best practices

            Format your response in clear markdown with appropriate sections.

      - name: Post AI analysis to PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const persona = '${{ steps.select-persona.outputs.persona }}';
            const aiAnalysis = '${{ steps.ai-analysis.outputs.response }}';

            const comment = `## 🤖 AI Infrastructure Analysis

            **Analyzed by**: ${persona}

            ${aiAnalysis}

            ---
            *This analysis was generated by AI using the GitHub Models API. Please review recommendations carefully before implementing.*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
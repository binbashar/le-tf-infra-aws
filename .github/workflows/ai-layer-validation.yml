name: AI-Powered Infrastructure Validation

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - 'apps-devstg/us-east-1/secrets-manager/**/*.tf'
      - 'apps-devstg/us-east-1/secrets-manager/**/*.tfvars'
      - 'apps-devstg/us-east-1/secrets-manager/**/*.hcl'
  issue_comment:
    types: [created]

permissions:
  contents: read       # Required to read repository contents
  pull-requests: write # Required to post PR comments
  issues: write        # Required for @aibot interactions
  models: read         # Required for GitHub Models API

env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  AWS_REGION: us-east-1

jobs:
  # Job 1: Detect affected layers from changed files
  detect-layers:
    name: Detect Modified Layers
    runs-on: ubuntu-latest
    outputs:
      layers: ${{ steps.parse-layers.outputs.layers }}
      has-changes: ${{ steps.parse-layers.outputs.has-changes }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Parse modified layers
        id: parse-layers
        run: |
          # Get changed files
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            CHANGED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }}..${{ github.event.pull_request.head.sha }})
          else
            CHANGED_FILES=$(git diff --name-only HEAD~1)
          fi

          echo "Changed files:"
          echo "$CHANGED_FILES"

          # Extract unique layer paths
          LAYERS=$(echo "$CHANGED_FILES" | grep -E '\.(tf|tfvars|hcl)$' | grep -E '^apps-devstg/us-east-1/secrets-manager/' | head -1 | xargs dirname | sort | uniq | jq -R -s -c 'split("\n")[:-1]')

          if [[ "$LAYERS" == "[]" || "$LAYERS" == "" ]]; then
            echo "has-changes=false" >> $GITHUB_OUTPUT
            echo "layers=[]" >> $GITHUB_OUTPUT
          else
            echo "has-changes=true" >> $GITHUB_OUTPUT
            echo "layers=$LAYERS" >> $GITHUB_OUTPUT
          fi

          echo "Detected layers: $LAYERS"

  # Job 2: Handle @aibot commands in issue comments
  handle-aibot-commands:
    name: Handle @aibot Commands
    runs-on: ubuntu-latest
    if: github.event_name == 'issue_comment' && contains(github.event.comment.body, '@aibot')

    steps:
      - name: Parse @aibot command
        run: |
          echo "Processing @aibot command: ${{ github.event.comment.body }}"
          # Add @aibot command handling logic here

  # Job 3: Validate each affected layer
  validate-layer:
    name: Validate Layer (${{ matrix.layer }})
    runs-on: ubuntu-latest
    needs: detect-layers
    if: needs.detect-layers.outputs.has-changes == 'true'
    strategy:
      matrix:
        layer: ${{ fromJson(needs.detect-layers.outputs.layers) }}
      fail-fast: false

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.13'
          cache: 'pip'

      - name: Setup Python virtual environment and Install Leverage CLI
        run: |
          echo "🐍 Creating Python virtual environment (mirroring local setup)"
          python3 -m venv ~/.leverage-venv
          source ~/.leverage-venv/bin/activate

          echo "📦 Installing latest Leverage CLI in virtual environment"
          pip install --upgrade pip
          pip install leverage

          echo "🔧 Configuring environment for subsequent steps"
          echo "VIRTUAL_ENV=$HOME/.leverage-venv" >> $GITHUB_ENV
          echo "$HOME/.leverage-venv/bin" >> $GITHUB_PATH

          echo "✅ Leverage CLI installed in virtual environment"
          leverage --version

      - name: Configure AWS credentials for Leverage CLI containers
        run: |
          # Parse layer information to determine AWS account
          LAYER_PATH="${{ matrix.layer }}"
          ACCOUNT=$(echo "$LAYER_PATH" | cut -d'/' -f1)

          echo "🔑 Configuring AWS credentials for Leverage CLI containers - Account: $ACCOUNT"

          # Simple environment variable setup for Leverage CLI containers
          echo "AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}" >> $GITHUB_ENV
          echo "AWS_DEFAULT_REGION=${{ env.AWS_REGION }}" >> $GITHUB_ENV
          echo "AWS_REGION=${{ env.AWS_REGION }}" >> $GITHUB_ENV

          echo "✅ AWS credentials configured for Leverage CLI containers"

      - name: Determine Terraform binary
        working-directory: ${{ matrix.layer }}
        run: |
          # Default to OpenTofu
          TF_COMMAND="tf"
          TF_BINARY="OpenTofu (default)"

          echo "✅ Selected binary: $TF_BINARY (command: leverage $TF_COMMAND)"
          echo "TF_COMMAND=$TF_COMMAND" >> $GITHUB_ENV

      - name: Setup Leverage environment
        working-directory: ${{ matrix.layer }}
        run: |
          # Navigate to repository root and create minimal build.env
          REPO_ROOT=$(git rev-parse --show-toplevel)
          cd "$REPO_ROOT"

          # Create minimal build.env configuration
          cat > build.env << EOF
          PROJECT=bb
          MFA_ENABLED=false
          TERRAFORM_IMAGE_TAG=1.9.1-tofu-0.3.0
          EOF

          # Source environment for subsequent steps
          source build.env
          echo "PROJECT=$PROJECT" >> $GITHUB_ENV
          echo "MFA_ENABLED=$MFA_ENABLED" >> $GITHUB_ENV
          echo "TERRAFORM_IMAGE_TAG=$TERRAFORM_IMAGE_TAG" >> $GITHUB_ENV

          echo "✅ Leverage environment configured with image: $TERRAFORM_IMAGE_TAG"

      - name: Pre-pull Leverage CLI Docker images
        run: |
          echo "🐳 Pre-pulling Leverage CLI Docker images to prevent build issues..."

          # Get the image tag from environment
          IMAGE_TAG="${TERRAFORM_IMAGE_TAG:-1.9.1-tofu-0.3.0}"
          LEVERAGE_IMAGE="binbash/leverage-toolbox:${IMAGE_TAG}"

          echo "📦 Pulling image: $LEVERAGE_IMAGE"

          # Pull the image with retry logic
          for i in {1..3}; do
            if docker pull "$LEVERAGE_IMAGE"; then
              echo "✅ Successfully pulled $LEVERAGE_IMAGE"
              break
            else
              echo "⚠️ Pull attempt $i failed, retrying..."
              sleep 5
            fi
          done

          # Verify the image was pulled successfully
          if docker images | grep -q "binbash/leverage-toolbox"; then
            echo "✅ Leverage CLI Docker image verified"
            docker images | grep "binbash/leverage-toolbox"
          else
            echo "❌ Failed to pull Leverage CLI Docker image"
            exit 1
          fi

          echo "✅ Docker image pre-pulling complete"

      - name: Setup Docker environment and mount sources
        working-directory: ${{ matrix.layer }}
        run: |
          # Setup Leverage environment with comprehensive Docker bind mount fixes
          ${GITHUB_WORKSPACE}/.github/scripts/setup-leverage-environment.sh

          # Validate and fix mount sources
          ${GITHUB_WORKSPACE}/.github/scripts/validate-mount-sources.sh

          # Test Docker mount configurations
          ${GITHUB_WORKSPACE}/.github/scripts/test-docker-mounts.sh

      - name: Detect optimal validation strategy
        working-directory: ${{ matrix.layer }}
        run: |
          # Ensure virtual environment is active
          source ~/.leverage-venv/bin/activate

          # Detect the best validation strategy for this environment
          ${GITHUB_WORKSPACE}/.github/scripts/detect-validation-strategy.sh

      - name: Container Health Check and Debugging
        working-directory: ${{ matrix.layer }}
        run: |
          # Ensure virtual environment is active
          source ~/.leverage-venv/bin/activate

          # Run comprehensive container health check
          ${GITHUB_WORKSPACE}/.github/scripts/container-health-check.sh

      - name: AWS Credentials and Connectivity Validation
        working-directory: ${{ matrix.layer }}
        run: |
          # Ensure virtual environment is active
          source ~/.leverage-venv/bin/activate

          # Run AWS connectivity validation
          ${GITHUB_WORKSPACE}/.github/scripts/aws-validation.sh

      - name: Run Leverage CLI validations
        working-directory: ${{ matrix.layer }}
        run: |
          echo "🚀 Starting Leverage CLI validations with strategy: ${VALIDATION_STRATEGY:-default}"

          # Ensure virtual environment is active
          source ~/.leverage-venv/bin/activate

          # Source validation strategies
          source ${GITHUB_WORKSPACE}/.github/scripts/run-validation-strategies.sh

          # Configuration paths
          BACKEND_CONFIG="../../config/backend.tfvars"
          ACCOUNT_CONFIG="../../config/account.tfvars"

          echo "📋 Configuration files:"
          echo "Backend config: $(ls -la $BACKEND_CONFIG 2>/dev/null || echo 'NOT FOUND')"
          echo "Account config: $(ls -la $ACCOUNT_CONFIG 2>/dev/null || echo 'NOT FOUND')"

          # Verify Leverage CLI command availability
          echo "🔍 Leverage CLI command availability check:"
          echo "Available tf subcommands:"
          leverage tf --help 2>&1 | grep -A 20 "Commands:" || echo "Could not get tf subcommands"
          echo "Leverage CLI version: $(leverage --version 2>&1 || echo 'Could not get version')"

          # Phase 1: Container Health Validation
          echo "🏥 Container Health Validation"
          echo "Docker status: $(docker --version 2>&1 || echo 'Docker not available')"
          echo "Docker containers: $(docker ps --format 'table {{.Names}}\t{{.Status}}' 2>&1 || echo 'No containers')"

          # Phase 2: AWS Credentials Validation
          echo "🔑 AWS Credentials Validation"
          echo "AWS_ACCESS_KEY_ID: ${AWS_ACCESS_KEY_ID:+configured}"
          echo "AWS_SECRET_ACCESS_KEY: ${AWS_SECRET_ACCESS_KEY:+configured}"
          echo "AWS_DEFAULT_REGION: ${AWS_DEFAULT_REGION:-not set}"

          # Phase 3: Progressive Leverage CLI Testing
          echo "🧪 Progressive Leverage CLI Testing"

          # Test 1: Basic help command (no container needed)
          run_validation "leverage --help" "Leverage CLI Help Test" || echo "⚠️ Help test failed, continuing..."

          # Test 2: Leverage CLI version (may use container)
          run_validation "leverage --version" "Leverage CLI Version Test" || echo "⚠️ Version test failed, continuing..."

          # Test 3: Terraform version through Leverage (requires container)
          run_validation "leverage --verbose tf version" "Leverage CLI Docker Integration Test" || echo "⚠️ Docker integration test failed, continuing..."

          # Test 4: Terraform format (if container integration works)
          run_validation "leverage --verbose tf format" "Terraform Format Test" || echo "⚠️ Format test failed, continuing..."

          # Backend initialization with fallback
          echo "⚡ Initializing with backend..."
          source ~/.leverage-venv/bin/activate
          if output=$(timeout 300 leverage --verbose tf init -no-color -backend-config=$BACKEND_CONFIG 2>&1); then
            echo "✅ Backend initialization successful"
            VALIDATION_RESULTS="${VALIDATION_RESULTS}## Terraform Backend Initialization\n✅ **PASSED**\n\`\`\`\n${output}\n\`\`\`\n\n"
            BACKEND_AVAILABLE=true
          else
            echo "⚠️ Backend init failed, trying syntax-only validation..."
            echo "Backend init error output: $output"
            VALIDATION_RESULTS="${VALIDATION_RESULTS}## Terraform Backend Initialization\n⚠️ **FAILED (trying syntax-only validation)**\n\`\`\`\n${output}\n\`\`\`\n\n"

            source ~/.leverage-venv/bin/activate
            if fallback_output=$(timeout 300 leverage --verbose tf init -no-color -backend=false 2>&1); then
              echo "✅ Syntax-only initialization successful"
              VALIDATION_RESULTS="${VALIDATION_RESULTS}## Terraform Syntax Initialization\n✅ **PASSED**\n\`\`\`\n${fallback_output}\n\`\`\`\n\n"
              BACKEND_AVAILABLE=false
            else
              echo "❌ Syntax-only initialization failed"
              echo "Syntax-only error output: $fallback_output"
              VALIDATION_RESULTS="${VALIDATION_RESULTS}## Terraform Syntax Initialization\n❌ **FAILED**\n\`\`\`\n${fallback_output}\n\`\`\`\n\n"
              VALIDATION_STATUS="failed"
              BACKEND_AVAILABLE=false
            fi
          fi

          # Run validation with enhanced strategy handling
          run_validation "leverage --verbose tf validate" "Terraform Validation" || echo "⚠️ Terraform validation failed, will try ultimate fallback..."

          # Create validation results directory
          mkdir -p /tmp/validation-results

          # Save validation results
          echo -e "$VALIDATION_RESULTS" > /tmp/validation-results/validation-summary.md
          echo "$VALIDATION_STATUS" > /tmp/validation-results/validation-status.txt

          # Output final results
          echo "🎯 Validation completed with status: $VALIDATION_STATUS"
          if [[ "$VALIDATION_STATUS" == "failed" ]]; then
            echo "❌ Primary validation failed - attempting ultimate fallback validation"

            # Run ultimate fallback validation
            source ~/.leverage-venv/bin/activate
            if ${GITHUB_WORKSPACE}/.github/scripts/ultimate-fallback-validation.sh; then
              echo "✅ Ultimate fallback validation successful"
              echo "⚠️ Note: Primary Leverage CLI validation failed, but basic infrastructure validation passed"
              exit 0
            else
              echo "❌ Both primary and fallback validation failed"
              exit 1
            fi
          else
            echo "✅ All validation steps passed"
            exit 0
          fi

      - name: Upload validation results
        uses: actions/upload-artifact@v4
        with:
          name: validation-results-${{ matrix.layer | replace('/', '-') }}
          path: /tmp/validation-results/
          retention-days: 1
          if-no-files-found: warn

  # Job 4: Post AI analysis results
  post-ai-analysis-results:
    name: Post AI Analysis Results
    runs-on: ubuntu-latest
    needs: [detect-layers, validate-layer]
    if: always() && needs.detect-layers.outputs.has-changes == 'true'

    steps:
      - name: Download validation results
        uses: actions/download-artifact@v4
        with:
          path: validation-results

      - name: Post results summary
        run: |
          echo "📊 Posting AI analysis results summary..."
          find validation-results -name "validation-summary.md" -exec cat {} \;

  # Job 5: AI Analysis with GitHub Models
  ai-analysis:
    name: AI Analysis
    runs-on: ubuntu-latest
    needs: [detect-layers, validate-layer]
    if: always() && needs.detect-layers.outputs.has-changes == 'true'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download validation results
        uses: actions/download-artifact@v4
        with:
          path: validation-results

      - name: Run AI analysis
        run: |
          echo "🤖 Running AI analysis with GitHub Models API..."
          echo "Analysis would be performed here on validation results"
name: Test | Leverage CLI

on:
  pull_request:
  workflow_dispatch:
    inputs:
      leverage_version:
        description: "Leverage CLI version to test"
        required: false
        type: string
        default: 1.13.0
      leverage_repo:
        description: "Whether to use pypi.org or test.pypi.org"
        required: false
        type: string
        default: "pypi.org"
      leverage_toolbox_version:
        description: "Leverage Toolbox version to test"
        required: false
        type: string
        default: 1.9.1-tofu-0.3.0
      target_layer:
        description: "Layer to test (relative to repo root, e.g., 'apps-devstg/global/cli-test-layer')"
        required: false
        type: string
        default: "apps-devstg/global/cli-test-layer"
      test_mode:
        description: "Test mode: 'full' (init+plan+apply+destroy) or 'plan-only' (init+plan)"
        required: false
        type: choice
        options:
          - "full"
          - "plan-only"
        default: "full"

jobs:
  test_leverage:
    runs-on: ubuntu-latest
    env:
      LEVERAGE_VERSION: 2.1.1
      LEVERAGE_REPO: pypi.org
      LEVERAGE_TOOLBOX_VERSION: 1.9.1-tofu-0.3.0
    steps:
      - name: Checkout base branch
        uses: actions/checkout@v3

      - uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: install_dependencies
        run: |
          pip3 install --user --upgrade pipenv
        shell: bash

      - id: cache-pipenv
        uses: actions/cache@v3
        with:
          path: /home/runner/.local/share/virtualenvs
          key: ${{ runner.os }}-pipenv-${{ github.run_id }}

      - name: Setup Python virtual environment and Install Leverage CLI
        run: |
          printf "[INFO] Setting up Python virtual environment\n"
          python3 -m venv ~/.leverage-venv
          source ~/.leverage-venv/bin/activate

          printf "[INFO] Installing Leverage CLI\n"
          pip install --upgrade pip
          if [[  "${{ inputs.leverage_version }}" == "" ]] || [[  "${{ inputs.leverage_repo }}" == "" ]];
          then
              echo "Installing latest leverage from ${LEVERAGE_REPO}"
              pip install leverage
          else
              echo "Installing leverage==${{ inputs.leverage_version }} from ${{ inputs.leverage_repo }}"
              pip install -i https://${{ inputs.leverage_repo }}/simple/ leverage==${{ inputs.leverage_version }}
          fi

          echo "VIRTUAL_ENV=$HOME/.leverage-venv" >> $GITHUB_ENV
          echo "$HOME/.leverage-venv/bin" >> $GITHUB_PATH

          leverage --version
        working-directory: ./apps-devstg/global/cli-test-layer

#      - name: patch_dependencies
#        run: |
#          python -m pipenv install requests==2.29.0
#        working-directory: ./apps-devstg/global/cli-test-layer

      - name: Set Leverage Toolbox version
        run: |
          printf "[INFO] Setting Leverage Toolbox version\n"
          if [[  "${{ inputs.leverage_toolbox_version }}" == "" ]];
          then
            # Read version from build.env as source of truth
            if [[ -f "build.env" ]]; then
              BUILD_ENV_VERSION=$(grep '^TERRAFORM_IMAGE_TAG=' build.env | cut -d'=' -f2)
              if [[ -n "$BUILD_ENV_VERSION" ]]; then
                echo "Using Toolbox version from build.env: $BUILD_ENV_VERSION"
                echo "This ensures workflow stays in sync with project configuration"
                # build.env already has the correct version, no need to modify
              else
                echo "Warning: No TERRAFORM_IMAGE_TAG found in build.env, using fallback: ${LEVERAGE_TOOLBOX_VERSION}"
                sed -E -i 's/^TERRAFORM_IMAGE_TAG=.+$/TERRAFORM_IMAGE_TAG='${LEVERAGE_TOOLBOX_VERSION}'/' build.env;
              fi
            else
              echo "Warning: build.env not found, using fallback: ${LEVERAGE_TOOLBOX_VERSION}"
              echo "TERRAFORM_IMAGE_TAG=${LEVERAGE_TOOLBOX_VERSION}" > build.env
            fi
          else
            echo "Using manually specified Toolbox ${{ inputs.leverage_toolbox_version }} version"
            sed -E -i 's/^TERRAFORM_IMAGE_TAG=.+$/TERRAFORM_IMAGE_TAG='${{ inputs.leverage_toolbox_version }}'/' build.env;
          fi

      - name: Set up credentials
        run: |
          printf "[INFO] Setting up credentials\n"
          mkdir -p  ~/.aws/bb
          aws configure set region us-east-1 --profile bb-apps-devstg-devops
          aws configure set output json --profile bb-apps-devstg-devops
          aws configure set role_arn arn:aws:iam::${{ secrets.AWS_DEVSTG_ACCOUNT_ID }}:role/DeployMaster --profile bb-apps-devstg-devops
          aws configure set source_profile bb-deploymaster --profile bb-apps-devstg-devops
          cat << EOF > ~/.aws/credentials
          [bb-deploymaster]
          aws_access_key_id = ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws_secret_access_key = ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          EOF
          cp ~/.aws/credentials ~/.aws/bb/
          cp ~/.aws/config ~/.aws/bb/

      - name: Configure Reference Architecture
        run: |
          echo "[INFO] Configure Reference Architecture\n"
          cat << EOF > ./config/common.tfvars
          project = "bb"
          project_long = "binbash"
          region_primary = "us-east-1"
          region_secondary = "us-east-2"
          vault_address = "vault_trash"
          vault_token = "vault_trash"
          sso_region = "us-east-1"
          sso_enabled = false
          sso_start_url = "sso_trash"

          accounts = {
            security = {
              id = ${{ secrets.AWS_SECURITY_ACCOUNT_ID }}
            }
          }
          EOF
          echo "[INFO] Disable MFA\n"
          sed -i "s/^\(MFA_ENABLED=\)true/\1false/" build.env

      - name: Setup AWS Environment Variables
        run: |
          # Set AWS configuration to use the bb directory (magic recipe)
          echo "AWS_CONFIG_FILE=$HOME/.aws/bb/config" >> $GITHUB_ENV
          echo "AWS_SHARED_CREDENTIALS_FILE=$HOME/.aws/bb/credentials" >> $GITHUB_ENV
          echo "AWS_PROFILE=bb-apps-devstg-devops" >> $GITHUB_ENV

          printf "[INFO] AWS Environment configured\n"
          printf "Config file: $HOME/.aws/bb/config\n"
          printf "Credentials file: $HOME/.aws/bb/credentials\n"
          printf "Profile: bb-apps-devstg-devops\n"

      - name: Validate Target Layer
        run: |
          TARGET_LAYER="${{ inputs.target_layer || 'apps-devstg/global/cli-test-layer' }}"
          echo "TARGET_LAYER=$TARGET_LAYER" >> $GITHUB_ENV

          printf "[INFO] Validating target layer: $TARGET_LAYER\n"

          if [[ ! -d "$TARGET_LAYER" ]]; then
            printf "[ERROR] Target layer directory does not exist: $TARGET_LAYER\n"
            printf "[ERROR] Available layers in apps-devstg/global:\n"
            find apps-devstg/global -type d -maxdepth 1 -name "*-*" | sort
            exit 1
          fi

          if [[ ! -f "$TARGET_LAYER/config.tf" ]]; then
            printf "[ERROR] Target layer does not contain config.tf: $TARGET_LAYER\n"
            printf "[ERROR] This does not appear to be a valid Terraform layer\n"
            exit 1
          fi

          printf "[INFO] Target layer validated: $TARGET_LAYER\n"
          printf "[INFO] Test mode: ${{ inputs.test_mode || 'full' }}\n"

      - name: Initialize Terraform Backend
        working-directory: ${{ env.TARGET_LAYER }}
        run: |
          # Ensure virtual environment is active
          source ~/.leverage-venv/bin/activate

          printf "[INFO] Initializing Terraform backend...\n"

          # Configuration paths and context
          BACKEND_CONFIG="../../config/backend.tfvars"

          # Initialize with timeout protection
          timeout 300 leverage tf init -no-color -backend-config=$BACKEND_CONFIG || {
            printf "[ERROR] Terraform init failed or timed out after 5 minutes\n"
            exit 1
          }

          printf "[INFO] Terraform backend initialized successfully\n"

      - name: Detect and Clear Stale State Locks
        working-directory: ${{ env.TARGET_LAYER }}
        run: |
          # Ensure virtual environment is active
          source ~/.leverage-venv/bin/activate

          printf "[INFO] Checking for stale state locks\n"

          # Try to get state lock info (now that backend is initialized)
          if ! leverage tf plan -detailed-exitcode -lock-timeout=30s > /dev/null 2>&1; then
            printf "[WARN] State appears to be locked, attempting to detect lock details\n"

            # Try to run plan to get lock error details
            LOCK_OUTPUT=$(leverage tf plan 2>&1 || true)

            # Extract lock ID if present
            LOCK_ID=$(echo "$LOCK_OUTPUT" | grep -o 'ID:[[:space:]]*[a-f0-9-]*' | cut -d':' -f2 | tr -d ' ' || echo "")

            if [[ -n "$LOCK_ID" ]]; then
              printf "[INFO] Found stale lock ID: $LOCK_ID\n"
              printf "[INFO] Attempting to force unlock\n"

              # Force unlock the stale lock
              echo "tofu force-unlock -force $LOCK_ID" | leverage tf shell || {
                printf "[ERROR] Failed to unlock state. Manual intervention required.\n"
                printf "[ERROR] Lock ID: $LOCK_ID\n"
                exit 1
              }

              printf "[INFO] State unlocked successfully\n"
            else
              # Check if it's just a normal terraform error (not a lock issue)
              if echo "$LOCK_OUTPUT" | grep -q "Backend initialization required"; then
                printf "[ERROR] Backend initialization failed\n"
                echo "$LOCK_OUTPUT"
                exit 1
              else
                printf "[WARN] Plan failed but no lock detected - may be configuration issue\n"
                printf "[INFO] Continuing with workflow...\n"
              fi
            fi
          else
            printf "[INFO] No state locks detected\n"
          fi

      - name: Test Infrastructure Layer
        working-directory: ${{ env.TARGET_LAYER }}
        run: |
          # These are later mounted in the container
          mkdir -p ~/.ssh && touch ~/.gitconfig

          # Ensure virtual environment is active
          source ~/.leverage-venv/bin/activate

          TEST_MODE="${{ inputs.test_mode || 'full' }}"
          printf "[INFO] Starting test for layer: ${{ env.TARGET_LAYER }}\n"
          printf "[INFO] Test mode: $TEST_MODE\n"

          # Phase 1: Initialize (always required)
          printf "[INFO] Initializing layer with timeout protection\n"
          timeout 300 leverage tf init || {
            printf "[ERROR] Terraform init timed out after 5 minutes\n"
            exit 1
          }

          # Phase 2: Plan (always required)
          printf "[INFO] Generating plan with lock timeout\n"
          timeout 600 leverage tf plan -lock-timeout=10m || {
            printf "[ERROR] Terraform plan timed out or failed\n"
            exit 1
          }

          # Phase 3: Apply/Destroy (only in full mode)
          if [[ "$TEST_MODE" == "full" ]]; then
            printf "[INFO] Running full test mode (apply + destroy)\n"

            printf "[INFO] Applying changes with timeout protection\n"
            timeout 1200 leverage tf apply -auto-approve -lock-timeout=10m || {
              printf "[ERROR] Terraform apply timed out after 20 minutes\n"
              printf "[WARN] State may be locked - manual cleanup required\n"
              exit 1
            }

            printf "[INFO] Checking if all changes were applied\n"
            leverage tf plan -detailed-exitcode -lock-timeout=5m
            PLAN_EXIT_CODE=$?
            [[ $PLAN_EXIT_CODE -eq 2 ]] && printf "[WARN] There are still remaining changes\n"
            [[ $PLAN_EXIT_CODE -eq 0 ]] && printf "[INFO] Apply checks out\n"

            printf "[INFO] Destroying all generated created resources\n"
            timeout 1200 leverage tf destroy -auto-approve -lock-timeout=10m || {
              printf "[ERROR] Terraform destroy timed out or failed\n"
              printf "[WARN] Resources may still exist - manual cleanup required\n"
              exit 1
            }

            printf "[INFO] Final verification - state should be clean\n"
            leverage tf plan -detailed-exitcode -lock-timeout=5m
            FINAL_EXIT_CODE=$?
            [[ $FINAL_EXIT_CODE -eq 0 ]] && printf "[INFO] State is clean - no resources remain\n"
            [[ $FINAL_EXIT_CODE -eq 2 ]] && printf "[WARN] Some resources may still exist\n"

          else
            printf "[INFO] Plan-only mode completed successfully\n"
            printf "[INFO] Skipping apply/destroy operations\n"
            printf "[INFO] Layer configuration validated successfully\n"
          fi

          printf "[INFO] Test completed for layer: ${{ env.TARGET_LAYER }}\n"
